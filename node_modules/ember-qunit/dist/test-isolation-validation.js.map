{"version":3,"file":"test-isolation-validation.js","sources":["../src/test-isolation-validation.js"],"sourcesContent":["/* eslint-disable no-console */\nimport * as QUnit from 'qunit';\nimport { _cancelTimers as cancelTimers } from '@ember/runloop';\nimport { waitUntil, isSettled, getSettledState } from '@ember/test-helpers';\nimport { getDebugInfo } from '@ember/test-helpers';\n\n/**\n * Detects if a specific test isn't isolated. A test is considered\n * not isolated if it:\n *\n * - has pending timers\n * - is in a runloop\n * - has pending AJAX requests\n * - has pending test waiters\n *\n * @function detectIfTestNotIsolated\n * @param {Object} testInfo\n * @param {string} testInfo.module The name of the test module\n * @param {string} testInfo.name The test name\n */\nexport function detectIfTestNotIsolated(test, message = '') {\n  if (!isSettled()) {\n    let { debugInfo } = getSettledState();\n\n    console.group(`${test.module.name}: ${test.testName}`);\n    debugInfo.toConsole();\n    console.groupEnd();\n\n    test.expected++;\n    test.assert.pushResult({\n      result: false,\n      message: `${message} \\nMore information has been printed to the console. Please use that information to help in debugging.\\n\\n`,\n    });\n  }\n}\n\n/**\n * Installs a hook to detect if a specific test isn't isolated.\n * This hook is installed by patching into the `test.finish` method,\n * which allows us to be very precise as to when the detection occurs.\n *\n * @function installTestNotIsolatedHook\n * @param {number} delay the delay delay to use when checking for isolation validation\n */\nexport function installTestNotIsolatedHook(delay = 50) {\n  if (!getDebugInfo()) {\n    return;\n  }\n\n  let test = QUnit.config.current;\n  let finish = test.finish;\n  let pushFailure = test.pushFailure;\n\n  test.pushFailure = function (message) {\n    if (message.indexOf('Test took longer than') === 0) {\n      detectIfTestNotIsolated(this, message);\n    } else {\n      return pushFailure.apply(this, arguments);\n    }\n  };\n\n  // We're hooking into `test.finish`, which utilizes internal ordering of\n  // when a test's hooks are invoked. We do this mainly because we need\n  // greater precision as to when to detect and subsequently report if the\n  // test is isolated.\n  //\n  // We looked at using:\n  // - `afterEach`\n  //    - the ordering of when the `afterEach` is called is not easy to guarantee\n  //      (ancestor `afterEach`es have to be accounted for too)\n  // - `QUnit.on('testEnd')`\n  //    - is executed too late; the test is already considered done so\n  //      we're unable to push a new assert to fail the current test\n  // - 'QUnit.done'\n  //    - it detaches the failure from the actual test that failed, making it\n  //      more confusing to the end user.\n  test.finish = function () {\n    let doFinish = () => finish.apply(this, arguments);\n\n    if (isSettled()) {\n      return doFinish();\n    } else {\n      return waitUntil(isSettled, { timeout: delay })\n        .catch(() => {\n          // we consider that when waitUntil times out, you're in a state of\n          // test isolation violation. The nature of the error is irrelevant\n          // in this case, and we want to allow the error to fall through\n          // to the finally, where cleanup occurs.\n        })\n        .finally(() => {\n          detectIfTestNotIsolated(\n            this,\n            'Test is not isolated (async execution is extending beyond the duration of the test).'\n          );\n\n          // canceling timers here isn't perfect, but is as good as we can do\n          // to attempt to prevent future tests from failing due to this test's\n          // leakage\n          cancelTimers();\n\n          return doFinish();\n        });\n    }\n  };\n}\n"],"names":["detectIfTestNotIsolated","test","message","isSettled","debugInfo","getSettledState","console","group","module","name","testName","toConsole","groupEnd","expected","assert","pushResult","result","installTestNotIsolatedHook","delay","getDebugInfo","QUnit","config","current","finish","pushFailure","indexOf","apply","arguments","doFinish","waitUntil","timeout","catch","finally","cancelTimers"],"mappings":";;;;AAAA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,uBAAuBA,CAACC,IAAI,EAAEC,OAAO,GAAG,EAAE,EAAE;EAC1D,IAAI,CAACC,SAAS,EAAE,EAAE;IAChB,IAAI;MAAEC;KAAW,GAAGC,eAAe,EAAE;IAErCC,OAAO,CAACC,KAAK,CAAE,GAAEN,IAAI,CAACO,MAAM,CAACC,IAAK,KAAIR,IAAI,CAACS,QAAS,EAAC,CAAC;IACtDN,SAAS,CAACO,SAAS,EAAE;IACrBL,OAAO,CAACM,QAAQ,EAAE;IAElBX,IAAI,CAACY,QAAQ,EAAE;IACfZ,IAAI,CAACa,MAAM,CAACC,UAAU,CAAC;MACrBC,MAAM,EAAE,KAAK;MACbd,OAAO,EAAG,GAAEA,OAAQ;KACrB,CAAC;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASe,0BAA0BA,CAACC,KAAK,GAAG,EAAE,EAAE;EACrD,IAAI,CAACC,YAAY,EAAE,EAAE;IACnB;;EAGF,IAAIlB,IAAI,GAAGmB,KAAK,CAACC,MAAM,CAACC,OAAO;EAC/B,IAAIC,MAAM,GAAGtB,IAAI,CAACsB,MAAM;EACxB,IAAIC,WAAW,GAAGvB,IAAI,CAACuB,WAAW;EAElCvB,IAAI,CAACuB,WAAW,GAAG,UAAUtB,OAAO,EAAE;IACpC,IAAIA,OAAO,CAACuB,OAAO,CAAC,uBAAuB,CAAC,KAAK,CAAC,EAAE;MAClDzB,uBAAuB,CAAC,IAAI,EAAEE,OAAO,CAAC;KACvC,MAAM;MACL,OAAOsB,WAAW,CAACE,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;;GAE5C;;;;;;;;;;;;;;;;;EAiBD1B,IAAI,CAACsB,MAAM,GAAG,YAAY;IACxB,IAAIK,QAAQ,GAAGA,MAAML,MAAM,CAACG,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IAElD,IAAIxB,SAAS,EAAE,EAAE;MACf,OAAOyB,QAAQ,EAAE;KAClB,MAAM;MACL,OAAOC,SAAS,CAAC1B,SAAS,EAAE;QAAE2B,OAAO,EAAEZ;OAAO,CAAC,CAC5Ca,KAAK,CAAC,MAAM;;;;;OAKZ,CAAC,CACDC,OAAO,CAAC,MAAM;QACbhC,uBAAuB,CACrB,IAAI,EACJ,sFACF,CAAC;;;;;QAKDiC,aAAY,EAAE;QAEd,OAAOL,QAAQ,EAAE;OAClB,CAAC;;GAEP;AACH;;;;"}